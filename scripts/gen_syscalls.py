#!/usr/bin/env python3
#
# Copyright (c) 2017 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

"""
Script to generate system call wrappers for FFI

This script parses the system call metadata JSON file emitted by
parse_syscalls.py to create two files:

- A header that includes all the individual generated syscall headers.

- A C file defining wrapper functions for every syscall that do nothing but
  pass through the arguments and return value. This allows creating real
  symbols for each syscall that can be called through FFI.
"""

import sys
import re
import argparse
import os
import json

syscall_template = """
/* auto-generated by gen_syscalls.py, don't edit */

#include <all_syscalls.h>

#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
#pragma GCC diagnostic push
#endif

#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

%s

#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
#pragma GCC diagnostic pop
#endif
"""

typename_regex = re.compile(r'(.*?)([A-Za-z0-9_]+)$')


class SyscallParseException(Exception):
    pass


def typename_split(item):
    if "[" in item:
        raise SyscallParseException(
            "Please pass arrays to syscalls as pointers, unable to process '%s'" %
            item)

    if "(" in item:
        raise SyscallParseException(
            "Please use typedefs for function pointers")

    mo = typename_regex.match(item)
    if not mo:
        raise SyscallParseException("Malformed system call invocation")

    m = mo.groups()
    return (m[0].strip(), m[1])

def wrapper_defs(func_name, func_type, args,):
    decl_arglist = ", ".join([" ".join(argrec) for argrec in args])

    syscall_list = "extern %s z_anyctx_%s(%s);\n" % (func_type, func_name, decl_arglist)
    syscall_list += "#ifdef CONFIG_USERSPACE\n"
    syscall_list += "extern %s z_kernelctx_%s(%s);\n" % (func_type, func_name, decl_arglist)
    syscall_list += "extern %s z_userctx_%s(%s);\n" % (func_type, func_name, decl_arglist)
    syscall_list += "#endif\n"

    wrap = "#if defined(__ZEPHYR_SUPERVISOR__)\n"
    wrap += "%s z_kernelctx_%s(%s)\n" % (func_type, func_name, decl_arglist)
    wrap += "#elif defined(__ZEPHYR_USER__)\n"
    wrap += "%s z_userctx_%s(%s)\n" % (func_type, func_name, decl_arglist)
    wrap += "#else\n"
    wrap += "%s z_anyctx_%s(%s)\n" % (func_type, func_name, decl_arglist)
    wrap += "#endif\n"
    wrap += "{\n"

    impl_arglist = ", ".join([argrec[1] for argrec in args])
    impl_call = "%s(%s)" % (func_name, impl_arglist)
    wrap += "\t" + "%s%s;\n" % ("return " if func_type != "void" else "",
                               impl_call)
    wrap += "}\n"

    return wrap, syscall_list

def analyze_fn(match_group):
    func, args = match_group

    try:
        if args == "void":
            args = []
        else:
            args = [typename_split(a.strip()) for a in args.split(",")]

        func_type, func_name = typename_split(func)
    except SyscallParseException:
        sys.stderr.write("In declaration of %s\n" % func)
        raise

    sys_id = "K_SYSCALL_" + func_name.upper()

    return wrapper_defs(func_name, func_type, args)

def parse_args():
    global args
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument("-i", "--json-file", required=True,
                        help="Read syscall information from json file")
    parser.add_argument("-t", "--thunks", required=True,
                        help="Output file for thunk definitions")
    parser.add_argument("-a", "--all-syscalls", required=True,
                        help="Output file for all syscalls header")
    args = parser.parse_args()


def main():
    parse_args()

    with open(args.json_file, 'r') as fd:
        syscalls = json.load(fd)

    invocations = []
    declarations = []
    includes = set()

    # Whitelist syscall groups for which to generate bindings. The syscall
    # headers are not self-sufficient, so we have to manually list the other
    # headers they need for their argument types.
    whitelist = set(["kernel.h", "kobject.h", "device.h", "uart.h", "mutex.h", "errno_private.h", "eeprom.h", "time.h"])
    includes = ["kernel.h", "device.h", "drivers/uart.h", "sys/mutex.h", "drivers/eeprom.h", "posix/time.h"]
    for match_group, fn in syscalls:
        if fn not in whitelist:
            continue
        include = "syscalls/%s" % fn
        if include not in includes:
            includes.append(include)
        invocation, declaration = analyze_fn(match_group)
        invocations.append(invocation)
        declarations.append(declaration)

    os.makedirs(os.path.dirname(args.thunks), exist_ok=True)
    os.makedirs(os.path.dirname(args.all_syscalls), exist_ok=True)

    includes = ["#include <%s>" % fn for fn in includes]
    with open(args.all_syscalls, "w") as fp:
        fp.write("#ifndef ZEPHYR_ALL_SYSCALLS_H\n")
        fp.write("#define ZEPHYR_ALL_SYSCALLS_H\n")
        fp.write("\n".join(includes))
        fp.write("\n")
        fp.write("".join(declarations))
        fp.write("\n#endif\n")

    thunks = syscall_template % ("\n\n".join(invocations))
    with open(args.thunks, "w") as fp:
        fp.write(thunks)

if __name__ == "__main__":
    main()
